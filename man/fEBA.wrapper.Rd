% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fEBA_Rfns.R
\name{fEBA.wrapper}
\alias{fEBA.wrapper}
\title{Implementing Iterative Empirical Band Analysis For Nonstationary Functional Time Series Data}
\usage{
fEBA.wrapper(X, Rsel, K, N, ndraw, alpha, std, blockdiag, dcap = 10^10)
}
\arguments{
\item{X}{A matrix with T rows and R columns, that is a realization of the Functional Time Series that will be analyzed. T is the length of the time series, and R is the number of points in the functional domain where the function is observed. The data must be entirely numeric.}

\item{Rsel}{The number of points within the functional domain that will be used for computing test statistics. Rsel must satisfy: 1 <= Rsel <= R}

\item{K}{The number of tapers to utilize in estimating the local power spectrum. K must satisfy: 1 <= K < floor(N/4 - 1)}

\item{N}{The number of observations that will be contained in each roughly stationary block. N must satisfy: 30 <= N <= T}

\item{ndraw}{The number of random draws from a Gaussian procedure that are needed to approximate the p-values.}

\item{alpha}{The numeric significance level for testing each frequency partition.}

\item{std}{A binary indicator to show whether the variance in each stationary block should be standardized.}

\item{blockdiag}{A binary indicator to show whether the covariance matrix for the gaussian process should be approximated with a block diagonal structure.}

\item{dcap}{The number of frequencies to test in a single pass}
}
\value{
A list containing 6 different objects: \cr \cr
1- A numeric vector, with the endpoints of the functional domain, along with any frequencies that were deemed to be significant partition points. \cr \cr
2- A list, where the first entry is the endpoints of the functional domain, and any additional entries consist of those endpoints, and any frequencies deemed significant. \cr \cr
3- A matrix that serves to summarize the results of each pass of the algorithm. \cr \cr
4- An array of the multitaper estimator of the power spectrum. \cr \cr
5- An array of the demeaned multitaper estimator of the power spectrum. \cr \cr
6- A list, containing the test statistics, critical values, p-values, and summary tables, for each frequency that was tested in each pass, in every component of the data.
}
\description{
Functional Data (either simulated or uploaded) is inputted into this algorithm, along with values for different parameters, in order to
return the frequencies at which significant partitions occur.
}
\details{
This code has only been tested for the following dimensions: T <= 50000, K <= 49, N <= 1000, Rsel <= 10 \cr \cr
Every input must be either a Boolean or Numeric, as mentioned above \cr \cr
}
\examples{
nb=15; #number of basis functions used to generate white noise
R=5; #number of points in functional domain
Ts=2000; #length of time series
seed=234; #seed for reproducibility
X=fws.sim(nb=nb,gsz=R,Ts=Ts,seed=seed);
B=5; #number of time blocks
N=Ts/B; #number of observations per time block
bw=0.04; #bandwidth for multitaper spectral estimator
K=max(1,floor(bw*(N+1)-1)); #number of tapers for multitaper spectral estimator
std=FALSE; #standardize variance for points in functional domain (TRUE) or not (FALSE)
freq=seq(from=0,by=1/N,length.out=floor(N/2)+1); #Fourier frequencies
Rsel=4; #number of points in functional domain used for test statistics
pse=fhat(X,N,K,Rsel,std);
cmpnt="1-1"; #select component to view
dimnames(pse) <- list(freq,apply(expand.grid(1:Rsel,1:Rsel),1,paste,collapse = "-"),1:B);
image.plot(x=(1:B)*(Ts/B),y=as.numeric(rownames(pse)),z=t(Re(pse[,cmpnt,])),
           axes = TRUE, col = inferno(256),
           main = 'Multitaper Autospectrum',xlab='Time',ylab='Hz',xaxs="i");
set.seed(47)
ndraw=100000; #number of draws from Gaussian process for approximating p-values
blockdiag=TRUE; #use block diagonal covariance matrix approximation
dcap=40; #max number of frequencies tested in a given pass
alpha=0.05/ceiling((1-2*bw/0.5)*(floor(N/2)+1)/dcap); #alpha with Bonferroni correction
run.wn <- fEBA.wrapper(X,Rsel,K,N,ndraw,alpha,std,blockdiag,dcap);
print(run.wn$summary);
}
\references{
https://arxiv.org/abs/2102.01784
}
